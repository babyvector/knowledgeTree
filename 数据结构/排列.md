## 力扣：幂集

> https://leetcode-cn.com/problems/power-set-lcci/

编写一种方法，返回某个集合的所有子集，集合中不包含重复的元素。
* 自己的思路使用递归去做（自己做这类题经常是这种思路）
	
		class Solution {//用时将近50分钟，这样不对
		public:
		    vector<vector<int>> rval;
		    void fillVec(vector<int>&resAnother, vector<int>&tmpRes, vector<int>&nums, int start, int n)
		    {
		        if( !(start <= nums.size()) || nums.size() -start < n)//start <= nums.size()中=号弄了好久
		            return ;
		        if(n == 0)
		        {
		            
		            rval.push_back(tmpRes);
		            int count = 0;
		            for(int i = start; i<nums.size(); i++)
		            {
		                resAnother.push_back(nums[i]);
		                count++;
		            }
		                
		            if(!resAnother.empty() && resAnother.size() != tmpRes.size())
		                rval.push_back(resAnother);
		
		            while(count--){
		                resAnother.pop_back();
		            }
		
		        }else{
		            for(int i = start; i<nums.size(); i++)
		            {
		                int count = 0;
		                for(int j = start; j<i; j++)
		                {
		                    count++;
		                    resAnother.push_back(nums[j]);
		                }
		                
		                tmpRes.push_back(nums[i]);
		                fillVec(resAnother, tmpRes, nums, i+1, n-1);
		                tmpRes.pop_back();
		
		                while(count--){
		                    resAnother.pop_back();
		                }
		            }
		        }
		    }
		    vector<vector<int>> subsets(vector<int>& nums) {
		        
		        size_t size = nums.size();
		        
		        vector<int> tmpRes;
		        vector<int> resAnother;
		        
		        for(int i = 1; i<=size/2; i++)//返回的集合中，个数的可能性
		        {
		                fillVec(resAnother, tmpRes, nums, 0, i);
		        }
		        rval.push_back({});
		        rval.push_back(nums);
		        
		        return rval;
		    }
		};
	
* 其他优秀的思路1

先在result列表中将入一个空子集
然后遍历nums每一个元素，将元素与result中的每个元素结合加到result中
直到nums遍历完

代码
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        result.append([])
        for i in nums:
            l = len(result)
            j = 0
            while j < l:
                result.append(result[j]+[i])
                j += 1
        return result

作者：txta
链接：https://leetcode-cn.com/problems/power-set-lcci/solution/mei-yi-ge-xin-yuan-su-jia-dao-qian-mian-de-yuan-su/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

* 其他优秀的思路2

[1,2,3] 可以分为000 001 010 011 100 101 110 111  0-7共8中二进制的组合

## 力扣：全排列

* 两种方法
	* 数组标记法
	* swap()方法