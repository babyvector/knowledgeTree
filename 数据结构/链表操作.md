## 返回倒数第k个节点

> https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

## 链表求和

> https://leetcode-cn.com/problems/sum-lists-lcci/

思路： 采用一位一位相加进位操作，防止溢出

拓展：如果是反向的求和则先翻转链表再按上面的操作

## 链表是否有环

## 链表中的环节点

* 力扣：环路检测

> https://leetcode-cn.com/problems/linked-list-cycle-lcci/

	ListNode *detectCycle(ListNode *head) {

        ListNode* fast = head;
        ListNode* slow = head;
        int circleLength = 0;
        do{
            if(fast == NULL)
                return NULL;
            fast = fast->next;
            
            if(fast == NULL)
                return NULL;
            fast = fast->next;

            if(slow == NULL)
                return NULL;
            slow = slow->next;
            circleLength++;
        }while(fast != slow);

        while(slow != head)
        {
            slow = slow->next;
            head = head->next;
        }
        return slow;
	}

	快慢双指针实现环路检测，最后由环路特性的相等特性找到相交的节点

> https://leetcode-cn.com/problems/linked-list-cycle-lcci/comments/

见当中的额评论有讲解是为什么?


## 两个链表是否相交，求相交的交点

先求两个链表的长度，之后再将链表对齐之后再操作。