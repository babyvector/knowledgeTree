## 以对象管理资源

作者的含义就是使用类似于只能指针的对象来管理资源，这样能够做到最终能够得到释放，而不用最后自己去delete，而且有可能还无法delete掉，因为delete之前有可能发生return或者抛出异常等其他行为。

* STL容器要求其元素发挥正常的复制行为。（能复制成两份，而不是复制得到一份之后，被复制者变为空）
* shared_ptr都在其析构函数内做delete而不是delete[]动作，这意味着在动态分配而得到的array身上使用shared_ptr是个馊主意，但是其仍然能够通过编译

## 条款15：在资源管理类中提供对原始资源的访问

* **疑问点：资源管理类与资源之间的隐式转化写法**

## 条款21：必须返回对象时，不要返回其引用

## 条款23：尽量使用非成员、非友元函数来替换成员函数

* 越多的东西被封装，越少的人可以看到它。而越少的人看到它，我们就有越大的弹性去改变它。
* 将非成员函数和类放入到一个命名空间中，**命名空间和类并不相同，命名空间可以跨越多个文件而类不行。**

## 条款25：考虑写出一个不抛出异常的swap函数

* 在这里使用了模板的特例化，模板特例化可以用来优化函数对某些特定类的操作

	namespace std{
		template<>//这一行表示swap的一个全特化版本，之后的Widget表示对Widget这个版本的特殊优化代码
		void swap<Widget>(Widget&a, Widget& b)
		{
			swap(a.pImpl, b.Impl);
		}

* C++只允许对class templates偏特化，在function templates身上偏特化是行不通的

## 条款25：考虑写出一个不抛出异常的swap函数

* 对std空间中的template进行特例化是鼓励的，但是不要尝试往空间中加入新的东西。
